1 - Implementing an active object whose behavior is represented by a state 
    machine with orthogonal regions. To do that, two alternatives are 
    introduced in this tutorial. The first one implement the entire active 
    object in one file, whereas the second alternative uses two files.
1.1 - Alternative 1: the state machines' active object are implemented in 
      only one file with its corresponding specification file.
1.1.1 - Specified entire active object (AcjObj.h file):
1.1.1.1 - Add a reference to active object in 'Declare active object' 
          section. This implies to declare a pointer to it. 
          RKH_SMA_DCLR(acjObj);
1.1.1.2 - Declare the active object constructor in 'Function prototypes' 
          section.
          void Sm_ctor(...)
1.1.2 - Implement entire active object (AcjObj.c file):
1.1.2.1 - Declare active object and its regions in Declares active object 
          section.
          typedef struct Region Region;
          typedef struct Sm Sm;
1.1.2.1 - Declare state machines' actions.
1.1.2.2 - Declare state machines' vertexes in 'Declares states and 
          pseudostates' section.
1.1.2.3 - Define state machines' vertexes in 'States and pseudostates' section.
1.1.2.4 - Define regions' properties and relations in 'Active Object' section.
          typedef struct Region Region;
          struct Region
          {
              RKH_SM_T base;
              ...
          }
1.1.2.5 - Define active object's properties and relations in 'Active Object' 
          section.
          typedef struct AcjObj AcjObj;
          struct AcjObj
          {
              RKH_SMA_T base;
              ...
          }
1.1.2.6 - Instantiate active object in 'Active Object' section.
          RKH_SMA_CREATE(AcjObj, acjObj, ...)
1.1.2.7 - Define a pointer to active object in 'Active Object' section.
          RKH_SMA_DEF_PTR(acjObj)
1.1.2.8 - Define the constant part of every particual region in 'Active 
          Object' section.
          RKH_SM_CONST_CREATE(region, ...)
1.1.2.9 - Define active object constructor
1.1.2.9.1 - Override active object operations if it is required
            me->vtbl = rkhSmaVtbl;
            me->vtbl.task = dispatch;
            ...
1.1.2.9.2 - Initialize active object's base class
            rkh_sma_ctor(RKH_UPCAST(RKH_SMA_T, me), &me->vtbl);
1.1.2.9.3 - Initialize regions' state machines
            RKH_SM_INIT(&me->region, region, ...)
1.1.2.7 - Implement state machine' actions

1.2 - Alternative 2: the state machines' active object are implemented in two 
      files, the first one for state machines' structure and the other one for 
      state machines' actions
1.2.1 - Specified state machines' structure and active object's properties 
        (AcjObj.h file):
1.2.1.1 - Declare the active object, which implies to declare a pointer to it. 
          This pointer is an opaque one, since it hides the active object's 
          properties.
          RKH_SMA_DCLR(acjObj);
1.2.1.2 - Declare state machines' vertexes.
1.2.1.3 - Define regions' properties and relations.
          typedef struct Region Region;
          struct Region
          {
              RKH_SM_T base;
              ...
          }
1.2.1.4 - Define active object's properties and relations.
          typedef struct AcjObj AcjObj;
          struct AcjObj
          {
              RKH_SMA_T base;
              ...
          }
1.2.2 - Specified state machines' actions (AcjObjAct.h file):
1.2.2.1 - Declare the active object constructor.
          void Sm_ctor(...)
1.2.2.2 - Declare state machines' actions.
1.2.3 - Define state machines' structure (AcjObj.c file):
1.2.3.1 - Define state machines' vertexes.
1.2.3.2 - Instantiate active object.
          RKH_SMA_CREATE(AcjObj, acjObj, ...)
1.2.3.3 - Define a pointer to active object.
          RKH_SMA_DEF_PTR(acjObj)
1.2.3.4 - Define the constant part of every region
          RKH_SM_CONST_CREATE(region, ...)
1.2.4 - Implement state machines' actions and active object constructor 
        (AcjObjAct.c file):
1.2.4.1 - Declare constant parts of regions
          RKH_DCLR_SM_CONST_GLOBAL(region)
1.2.4.2 - Define active object constructor
1.2.4.2.1 - Override active object operations if it is required
            me->vtbl = rkhSmaVtbl;
            me->vtbl.task = dispatch;
            ...
1.2.4.2.2 - Initialize active object's base class
            rkh_sma_ctor(RKH_UPCAST(RKH_SMA_T, me), &me->vtbl);
1.2.4.2.3 - Initialize regions' state machines
            RKH_SM_INIT(&me->region, region, ...)
1.2.4.3 - Implement state machine' actions

2 - Dispatch events to state machines
    One alternative to dispatch events to active object's regions is to 
    override the task operation of the active object base class in order to 
    dispatch events to its regions.
2.1 - Implement task operation
    static void
    dispatch(RKH_SMA_T *me, void *arg)
    {
        Region *region;

        region = &(RKH_DOWNCAST(ActObj, me)->itsRegion);
        /* dispath received event to active object's region */
        rkh_sm_dispatch((RKH_SM_T *)me, (RKH_EVT_T *)arg);
        /* and then to the rest */
        rkh_sm_dispatch(RKH_UPCAST(RKH_SM_T, region), (RKH_EVT_T *)arg);
    }

2.2 - Override default task operation
    Actobj_ctor(...)
    {
        ActObj *me;

        me = RKH_DOWNCAST(ActObj, actObj);
        me->vtbl = rkhSmaVtbl;
        me->vtbl.task = dispatch;
        ...
    }

3 - Activate active object
    ...
    #include "ActObj.h"
    #include "ActObjAct.h"   /* Only if it uses Alternative 2 */
    ...
    main(void)
    {
        ...
        ActObj_ctor();
        ...
        RKH_SMA_ACTIVATE(actObj, ...);
    }
